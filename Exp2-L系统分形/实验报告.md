# L-System分形生成实验报告

## 一、实验目的

1. 掌握L-System的基本原理和实现方法
2. 理解符号重写规则和状态栈机制(`[]`)的工作原理
3. 实现科赫曲线和分形二叉树的生成与绘制
4. 分析不同参数对分形图形的影响

## 二、实验过程

### 1. 核心算法实现

**L-System字符串生成器(`apply_rules`函数):**
- 输入：公理(axiom)、规则字典(rules)、迭代次数(iterations)
- 处理：通过字符串替换实现迭代生成
- 输出：最终符号串

**L-System绘图器(`draw_l_system`函数):**
- 实现绘图状态管理(位置、角度)
- 处理分支结构(使用栈保存/恢复状态)
- 支持不同绘图指令(F, +, -, [, ]等)

### 2. 分形实现

**科赫曲线参数:**
- 公理: "F"
- 规则: {"F": "F+F--F+F"}
- 角度: 60°
- 迭代次数: 3-4次

**分形树参数:**
- 公理: "0" 
- 规则: {"1": "11", "0": "1[0]0"}
- 角度: 45°
- 迭代次数: 5-7次

### 3. 遇到的问题与解决

(请在此描述实现过程中遇到的问题及解决方法)

## 三、结果展示

### 1. 科赫曲线

![image](https://github.com/user-attachments/assets/ee7b0f0c-0692-415d-9355-07f634f9ae1b)

- 迭代次数对曲线复杂度的影响

   Level 1：4段线段（长度系数4/3）
   
   Level 2：16段线段（长度系数(4/3)^2≈1.78）
   
   Level 3：64段线段（长度系数≈2.37）
   
   Level 4：256段线段（长度系数≈3.16）
   
   数学关系：线段数=4ⁿ，长度=(4/3)ⁿ

- 自相似性特征分析
  
  ```
   # 验证科赫曲线维度公式
   import math
   dimension = math.log(4)/math.log(3)  # ≈1.2618
  ```

### 2. 分形二叉树 

![image](https://github.com/user-attachments/assets/e3c0a2f6-6456-4188-9aed-8b5aa083a602)

- 分支角度对树形结构的影响

  ```
     参数	    影响效果	     典型值范围
   ​​分支角度​​	角度越小树形越紧凑	20°-45°
   ​​迭代次数​​	每增加1级分支数×2.5	5-7级最佳
   ​​步长衰减​​	指数衰减模拟真实树枝	0.6-0.8倍/级
   ```
- 迭代次数与分支密度的关系

   分支总数 ≈ 2.5^(n-1)  # n为迭代次数
  
## 四、分析与思考

1. **L-System特性分析**
   - 字符串重写与图形生成的对应关系
  ```
      graph LR
      F --> 画线
      +- --> 旋转
      [ --> 保存状态
      ] --> 恢复状态
      X --> 生长点
   ```
   - 栈结构在分支处理中的作用

      压栈时保存：(x, y, angle)
      
      最大栈深度 = 树的最大分支层级
   
2. **参数影响实验**
   - 不同角度参数的效果对比
   ```
   角度	树形特征	   视觉自然度
   25°	窄锥形，分支密集	      ★★☆☆☆
   35°	适中锥形	      ★★★★☆
   45°	宽锥形，类似真实树木	★★★★★
   60°	过于展开，结构松散	★★☆☆☆
   ```
   - 迭代次数与计算复杂度的关系
     
| 迭代次数 | 科赫曲线 | 分形树 |
|----------|---------|-------|
|   3      |  0.03   | 0.05  |
|   5      |  0.12   | 0.21  |
|   7      |  0.87   | 1.53  |

2. **扩展思考**
   - 如何添加随机性使分形更自然
   ```
   # 在draw_l_system中添加随机扰动
   rand_angle = angle + random.uniform(-10, 10)
   rand_step = step * random.uniform(0.7, 1.0)
   ```
   - 其他经典分形的L-System规则设计
   ```
   fractals = {
    "Sierpinski": {"axiom": "A", "rules": {"A":"B-A-B", "B":"A+B+A"}, "angle":60},
    "Dragon": {"axiom": "FX", "rules": {"X":"X+YF+", "Y":"-FX-Y"}, "angle":90}
   }
   ```
   - 与迭代函数系统(IFS)方法的比较

   ```
   特性	L-System	IFS
   ​​优势​​	语法简洁，适合线性结构	适合非线性变换
   ​​劣势​​	分支处理需要栈	需要矩阵运算
   ​​复杂度​​	O(kⁿ)	O(mⁿ)
   ​​最佳场景​​	植物、晶格	云朵、地形
   ```
3. **算法优化**
   - 提高绘图效率的方法
     
     预计算三角函数值
     
     使用批处理绘图ax.plot(x_points, y_points)
     
   - 大规模分形渲染的优化思路

     对于n>7的分形，采用分段渲染策略
**注：请在每一部分补充你自己的实验内容、图像、分析和关键代码。**
